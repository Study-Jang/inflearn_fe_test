### 단위 테스트 대상 선정하기

<hr/>

```
💡 단위 테스트 전략
- state나 로직처리 없이 UI만 그리는ㄴ 컴포넌트는 단위 테스트 말고 스토리북과 같은 도구를 통해 검증한다.
- 간단한 로직 처리만 하는 컴포넌트는 단위 테스트 보단, 상위 컴포넌트의 통합 테스트에서 검증한다.
- 다른 모듈과 의존성이 없고, 여러곳에서 사용되는 것들이 단위 테스트에 적합하다
ex) 리액트 훅 | 공통 유틸 함수
```

<hr/>

### 모듈 모킹(Mocking)

<hr/>

#### 모킹
- 외부 모듈에 대한 호출 여부를 판단하기 위해 모킹을 사용한다
- 실제 모듈/객체와 동일한 동작을 하도록 만든 모의 모듈/객체(Mock)로 실제를 대체한다

```
장점
- 외부 모듀로가 의존선을 제외한 필요한 부분만 검증이 가능

단점
- 실제 모듈과 완전히 동일한 모의 객체를 구현하는것은 큰 비용임
- 모의 객체를 남용하는건 테스트 신뢰성을 낮춤
```

#### 모킹 초기화
- 다른 테스트에서 특정 모듈에 대한 모킹이 필요 없다면?
- 특정 테스트의 모킹 작업이 다른 테스트에 영향을 준다면?

-> 테스트를 실행한 뒤에는 명시적으로 모킹을 초기화 해야한다.

```js
//setupTests.js


afterEach(() => {
  server.resetHandlers();
  // 모킹된 모의 객체 호출에 대한 히스토리 초기화
  // 모킹된 모듈의 구현을 초기화 하지 않는다. -> 모킹된 상태로 유지됨
  // -> 모킹 모듈 기반으로 작성한 테스트가 올바르게 실행
  // 반면, 모킹 히스토리가 계속 쌓임 (호출 횟수나 인자가 계속 변경)-> 다른 테스트에 영향을 줄 수 있음
  vi.clearAllMocks();
});

afterAll(() => {
  //모킹 모듈에 대한 모든 구현을 초기화
  vi.resetAllMocks();
  server.close();
});

```

<hr/>

### 리액트 훅 테스트(feat.act 함수)

<hr/>

```
act함수
- act함수는 상호 작용(렌더링, 이펙트 등..)을 함께 그룹화하고 실행해 렌더링과 업데이트가 실제 앱이 동작하는 것과 유사한 방식으로 동작함
- 즉, 테스트 환경에서 act를 사용하면 가상의 돔(jsdom)이 제대로 반영되었다는 가정하에 테스트가 가능해짐
- 컴포넌트 렌더링한 뒤 업데이트 하는 코드의 결과를 검증하고 싶을 때 사용
```

💡 리액트 테스팅 라이브러리의 render(), user-event는 컴포넌트 렌더링, 이벤트 핸들러 처리를 할때 모두 내부적으로 act함수를 홓출하여 동작한다

```js
  // result: 훅을 호출하여 얻은 결과 값을 반환 -> result.current 값을 참초를 통해 최신 상태로 추적할 수 있다.
  // rerender: 훅을 원하는 인자와 함께 새로 호출하여 상태를 갱신한다
  const { result, rerender } = renderHook(useConfirmModal);
```
<hr/>

### 타이머 테스트

<hr/>

```js

   beforeEach(() => {
    vi.useFakeTimers(); //타이머 모킹 함수
    vi.setSystemTime(new Date('2025-01-20')); //특별한 날을 고정 할 수 있음
  });


  afterEach(() => {
    vi.useRealTimers(); //타이머를 원래대로 되돌림
  });


  vi.advanceTimersByTime(300); //300ms 시간이 흐른 것 처럼 제어

```

<hr/>

### userEvent를 사용한 사용자 상호작용 테스트

<hr/>
```
🔥fireEvent
- DOM이벤트를 시뮬레이션 하기 위해 제공
- 내장되어 있기 때문에 별도의 설치 불필요
```

userEvent vs fireEvent
- fireEvent는 단순히 해당 이벤트만 디스패치한다. -> 실제 사용자가 사용할때 처럼 다양한 이벤트들이 시뮬레이션 되지는 않음
- fireEvent는 실제 상황과 거리가 있다, 하지만 사용자가 실제 요소를 클릭하였을때 pointerdown, click, focus 등의 이벤트들이 연쇄적으로 발생 하는데 fireEvent는 이걸 고려하지 않는다
- 반면 userEvent는 실제 사용자가 사용하는 것처럼 이벤트가 연쇄적으로 발생한다. 테스트의 신뢰성이 더 좋음으로 fireEvent보단 useEvent 사용을 권장
- 하지만!!! scroll이나 단순한 컴파운트 검증은 fireEvnet로 해야한다(useEvent는 scroll에 대한 처리가 불가능)

<hr/>

### 단위 테스트의 한계

<hr/>

#### 단위 테스트
- 공통 컴포넌트, 커스텀 훅, 공통 유틸처럼 다른 모듈에 대한 의존성이 거의 없을때
- 해당 모듈 자체만으로 작지만 독립적인 역할을 할때.. 유용함

- 하지만 여러 모듈이 조합되었을때 발생하는 이슈는 찾을 수 없음
- 앱의 전반적인 기능이 비즈니스 요구사항에 맞게 동작하는지 보장할 수 없음

<hr/>